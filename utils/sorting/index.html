<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap");

      * {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
      }

      body {
        background: #212833;
        box-shadow: inset 0 70px 80px rgb(0 0 0 / 21%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: auto;
        font-family: "Poppins", sans-serif;
      }

      /* =============  Scrollbar  ============= */
      ::-webkit-scrollbar {
        width: 4px;
      }
      ::-webkit-scrollbar-track {
        background: #000;
      }
      ::-webkit-scrollbar-thumb {
        background: white;
      }

      #header {
        width: 1400px;
        margin-top: 1rem;

        box-shadow: 10px 10px 30px rgba(0, 0, 0, 0.363);
        border-radius: 10px;
        background-color: rgba(255, 255, 255, 0.1);
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-top: 1px solid rgba(255, 255, 255, 0.4);
        border-left: 1px solid rgba(255, 255, 255, 0.4);
        font-family: "Poppins", sans-serif;
        backdrop-filter: blur(8px);
      }
      #header a {
        text-decoration: none;
      }
      #title {
        text-align: center;
        font-size: 2rem;
        /* color: rgb(90, 0, 90) ; */
        color: rgb(244, 244, 244);
        padding: 1rem 0;
        font-weight: bold;
      }

      #header > div {
        flex-grow: 1;
      }

      #headerLeft {
        display: flex;
        align-items: center;
        padding-left: 40px;
        justify-content: space-between;
        width: 65%;
      }
      .headerLeftContent {
        display: flex;
      }
      .slidecontainer {
        position: relative;
        margin-right: 20px;
      }
      .slider {
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
      }
      .slider:hover {
        opacity: 1;
      }
      .slider::-webkit-slider-thumb {
        cursor: pointer;
      }
      .sliderValue {
        position: absolute;
        top: 20px;
        left: 40px;
      }
      .speedValue {
        position: absolute;
        top: 20px;
        left: 40px;
      }

      a {
        text-decoration: none;
      }

      #headerRight {
        text-align: right;
        padding-right: 55px;
        width: 35%;
      }
      #sort_type {
        position: absolute;
        right: 0 !important;
        top: 1.5rem;
        margin-right: 2rem;
        padding: 0.5rem 1rem;
        border-radius: 5px;
        background: #161824;
        color: white;
        outline: none;
        border: none;
      }

      #container {
        display: flex;
        width: 99%;
        min-width: 99%;
        height: 570px;
        margin-left: auto;
        margin-right: auto;
        position: relative;
        margin-top: 25px;
      }

      .bar {
        margin-right: 1px;
        align-self: flex-end;
        transition: 0.2s transform ease;
        position: absolute;
      }
      .barValue {
        margin-right: 1px;
        align-self: flex-end;
        transition: 0.2s transform ease;
        position: absolute;
        color: red;
        font-weight: bold;
      }

      .button {
        padding: 0.8rem 1.4rem;
        font-size: 1rem;
        color: white;
        border-radius: 5px;
        background: #161824;
        letter-spacing: 1.2px;
        border: none;
        outline: none;
        margin-top: 1rem;
        transition: all 0.25s ease-in-out;
      }
      .button:hover {
        cursor: pointer;
        transform: scale(1.1) perspective(1px);
      }
      #buttonsdiv {
        text-align: center;
        margin-bottom: 30px;
      }
      #sortButton {
        margin-right: 10px;
      }
      #stopButton {
        margin-left: 10px;
      }

      #generateButton {
        padding: 0.4rem 0.8rem;
        font-size: 16px;
        border-radius: 5px;
        margin-top: 0px;
        font-size: 0.9rem;
      }
      #generateButton:hover {
        transform: scale(1.08) perspective(1px);
      }

      @media (max-width: 900px) {
        #title {
          font-size: 0px;
        }
        .slidecontainer,
        #sort_type {
          margin-top: 0px;
        }
      }

      #element {
        padding: 10px;
        min-width: 250px;
      }
    </style>

    <title>Interactive Algorithm | Sorting</title>
  </head>

  <body>
    <div id="header">
      <div id="headerLeft">
        <div class="headerLeftContent">
          <div class="slidecontainer">
            <input
              type="range"
              min="25"
              max="300"
              value="150"
              class="slider"
              id="speedSlider"
            />
            <div class="speedValue">Speed</div>
          </div>
          <div class="slidecontainer">
            <input
              type="range"
              min="10"
              max="100"
              value="50"
              class="slider"
              id="barSlider"
            />
            <div class="sliderValue">Bars: 50</div>
          </div>
          <button class="button" id="generateButton">Generate</button>
        </div>
        <a href="/index.html"><div id="title">Sorting Visualizer</div></a>
      </div>
      <div id="headerRight">
        <select id="sort_type" name="sort_type">
          <option value="insertion" selected>Insertion Sort</option>
          <option value="bubble">Bubble Sort</option>
          <option value="merge">Merge Sort</option>
          <option value="selection">Selection Sort</option>
          <option value="quick">Quick Sort</option>
        </select>
      </div>
    </div>
    <div id="container"></div>

    <div id="buttonsdiv">
      <input
        type="text"
        placeholder="Enter space separated numbers"
        name="element"
        id="element"
      />
      <button type="button" id="inputButton" class="button">Input</button>
      <button type="button" id="clearButton" class="button">Clear</button>
      <button type="button" id="sortButton" class="button">Sort</button>
      <button type="button" id="pauseButton" class="button">Pause</button>
      <button type="button" id="stopButton" class="button">Stop</button>
    </div>

    <script>
      let heights = [];
      let bars = [];
      let barValues = [];

      let barSlider = document.getElementById("barSlider");
      let n = barSlider.value;
      let speedSlider = document.getElementById("speedSlider");
      let delay = 375 - speedSlider.value;
      var inputElement = document.getElementById("element");

      let container = document.getElementById("container");
      let width = container.offsetWidth;
      let height = container.offsetHeight;
      let lineWidth = width / n - 1;

      let isStopped = true;
      let isPaused = false;
      let isGenerated = true;
      let isSorted = false;

      // stack implementation.
      class Stack {
        constructor() {
          this.arr = [];
          this.top = -1;
        }
        push(element) {
          this.top++;
          this.arr.push(element);
        }
        isEmpty() {
          return this.top == -1;
        }
        pop() {
          if (this.isEmpty() === false) {
            this.top = this.top - 1;
            return this.arr.pop();
          }
        }
      }

      // get random value between min and max;
      function getRandomValue(min, max) {
        return Math.random() * (max - min) + min;
      }
      // Generate random heights of the bar and create div element of the bar.
      function generateRandomArray() {
        isGenerated = true;
        isSorted = false;
        isStopped = true;
        isPaused = false;
        n = barSlider.value;
        lineWidth = width / n - 1;
        container.innerHTML = "";
        for (let i = 0; i < n; i++) {
          heights[i] = parseInt(getRandomValue(1, height));
          bars.push(document.createElement("div"));
          bars[i].style.width = `${lineWidth}px`;
          bars[i].style.height = `${heights[i]}px`;
          bars[i].style.transform = `translate(${i * lineWidth + i}px)`;
          bars[i].style.backgroundColor = "white";
          bars[i].className = "bar";
          container.appendChild(bars[i]);

          // if there are more numer of bars then it is not feasible to show bar values because they gets mixed up.
          if (n <= 60) {
            barValues.push(document.createElement("div"));
            barValues[i].innerHTML = heights[i];
            barValues[i].style.marginBottom = `${heights[i] + 5}px`;
            barValues[i].style.transform = `translate(${i * lineWidth + i}px)`;
            barValues[i].className = "barValue";
            container.appendChild(barValues[i]);
          }
        }
      }
      generateRandomArray();

      // swap 2 bars and also swap trnasform property for the animation.
      function swap(i, minindex) {
        [heights[i], heights[minindex]] = [heights[minindex], heights[i]];

        [bars[i], bars[minindex]] = [bars[minindex], bars[i]];
        [bars[i].style.transform, bars[minindex].style.transform] = [
          bars[minindex].style.transform,
          bars[i].style.transform,
        ];

        [barValues[i], barValues[minindex]] = [
          barValues[minindex],
          barValues[i],
        ];
        [barValues[i].style.transform, barValues[minindex].style.transform] = [
          barValues[minindex].style.transform,
          barValues[i].style.transform,
        ];
      }
      // Draw bars with their new Updated heights.
      function draw(coloredBars, colors) {
        // coloredBars contains indices of the bars which will be in different color than default color
        // colors array stores color for different bars.
        for (let i = 0; i < n; i++) {
          bars[i].style.backgroundColor = "white";
          for (let j = 0; j < coloredBars.length; j++) {
            if (i == coloredBars[j]) {
              bars[i].style.backgroundColor = colors[j];
              break;
            }
          }
        }
      }

      // to put delay between visualization.
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      // Play animation after sorting process is finished
      async function SortedAnimation() {
        // first we will go from left to right and color them in some color.
        // then we will again go from left to right and color them white.
        for (let i = 0; i < n; i++) {
          bars[i].style.backgroundColor = "lime";
          await sleep(10);
        }
        await sleep(300);
        for (let i = 0; i < n; i++) {
          bars[i].style.backgroundColor = "white";
          await sleep(10);
        }
      }

      // Sorting algos implementation starts...
      async function bubbleSort() {
        for (let i = 0; i < n - 1; i++) {
          for (let j = 0; j < n - i - 1; j++) {
            if (isStopped) {
              draw([], []);
              return;
            }
            if (!isPaused) {
              if (heights[j] > heights[j + 1]) {
                swap(j, j + 1);
              }
              draw([j, j + 1], ["green", "yellow"]);
            } else {
              j--;
            }
            await sleep(delay);
          }
        }
        console.log("Bubble sort completed.");
        draw([], []);
        isSorted = true;
        isStopped = true;
        isPaused = false;
        SortedAnimation();
      }

      async function selectionSort() {
        for (let i = 0; i < n - 1; i++) {
          let minIndex = i;
          for (let j = i + 1; j < n; j++) {
            if (isStopped) {
              draw([], []);
              return;
            }
            if (!isPaused) {
              if (heights[j] < heights[minIndex]) {
                minIndex = j;
              }
              draw([i, j, minIndex], ["blue", "red", "green"]);
            } else {
              j--;
            }
            await sleep(delay);
          }
          swap(i, minIndex);
        }
        console.log("Selection sort completed.");
        draw([], []);
        isSorted = true;
        isStopped = true;
        isPaused = false;
        SortedAnimation();
      }

      async function insertionSort() {
        for (let i = 0; i < n; i++) {
          let key = heights[i];
          for (let j = i - 1; j >= 0 && heights[j] > key; j--) {
            if (isStopped) {
              draw([], []);
              return;
            }
            if (!isPaused) {
              swap(j, j + 1);
              draw([j, i + 1], ["green", "red"]);
            } else {
              j++;
            }
            await sleep(delay);
          }
        }
        console.log("Insertion sort completed.");
        draw([], []);
        isSorted = true;
        isStopped = true;
        isPaused = false;
        SortedAnimation();
      }

      async function mergeSort() {
        for (let curSize = 1; curSize < n; curSize *= 2) {
          for (let start = 0; start < n - 1; start += 2 * curSize) {
            let mid = Math.min(start + curSize - 1, n - 1);
            let end = Math.min(start + 2 * curSize - 1, n - 1);
            let n1 = mid - start + 1;
            let n2 = end - mid;
            let L = [],
              R = [];
            for (let i = 0; i < n1; i++) L.push(heights[start + i]);
            for (let j = 0; j < n2; j++) R.push(heights[mid + 1 + j]);
            let i = 0,
              j = 0,
              k = start;

            let barsIndices = [];
            let barsColors = [];
            for (let i1 = start; i1 <= end; i1++) {
              barsIndices.push(i1);
              barsColors.push("yellow");
            }

            while (i < n1 || j < n2) {
              if (isStopped) {
                draw([], []);
                return;
              }
              if (!isPaused) {
                if (j == n2 || (i < n1 && L[i] <= R[j])) {
                  draw([k, ...barsIndices], ["green", ...barsColors]);
                  i++;
                } else {
                  for (let i1 = mid + 1 + j; i1 > k; i1--) {
                    swap(i1, i1 - 1);
                  }
                  draw([k, ...barsIndices], ["green", ...barsColors]);
                  j++;
                }
                k++;
              }
              await sleep(delay);
            }
          }
        }
        console.log("Merge sort completed.");
        draw([], []);
        isSorted = true;
        isStopped = true;
        isPaused = false;
        SortedAnimation();
      }

      async function quickSort() {
        let s = new Stack();
        s.push(0);
        s.push(n - 1);
        while (!s.isEmpty()) {
          let h = s.pop();
          let l = s.pop();

          let i = l - 1;

          let barsIndices = [];
          let barsColors = [];
          for (let i1 = l; i1 <= h; i1++) {
            barsIndices.push(i1);
            barsColors.push("yellow");
          }

          for (let j = l; j <= h - 1; j++) {
            if (isStopped) {
              draw([], []);
              return;
            }
            if (!isPaused) {
              draw([i, j, ...barsIndices], ["green", "red", ...barsColors]);
              if (heights[j] <= heights[h]) {
                i++;
                swap(i, j);
              }
            } else {
              j--;
            }
            await sleep(delay);
          }
          swap(i + 1, h);
          let partition = i + 1;
          if (l < partition - 1) {
            s.push(l);
            s.push(partition - 1);
          }
          if (partition + 1 < h) {
            s.push(partition + 1);
            s.push(h);
          }
        }
        console.log("Quick sort completed.");
        draw([], []);
        isSorted = true;
        isStopped = true;
        isPaused = false;
        SortedAnimation();
      }

      // when slider value is changed generate new bars and update the value of bar count on the navbar.
      barSlider.oninput = () => {
        document.querySelector(
          ".sliderValue"
        ).innerHTML = `Bars: ${barSlider.value}`;
        generateRandomArray();
      };

      speedSlider.oninput = () => {
        delay = 375 - speedSlider.value;
      };

      document
        .getElementById("generateButton")
        .addEventListener("click", generateRandomArray);

      document.getElementById("sortButton").addEventListener("click", () => {
        // get the name of selected sorting algorithm.
        type = document.getElementById("sort_type").value;

        // if there is another sorting visualization going on then return from the function.
        if (!isStopped) return;
        // if recently we used visualization and bars are sorted then generate new unsorted array.
        if (isSorted || !isGenerated) generateRandomArray();

        isGenerated = false;
        isPaused = false;
        isStopped = false;

        if (type == "bubble") bubbleSort();
        else if (type == "selection") selectionSort();
        else if (type == "insertion") insertionSort();
        else if (type == "merge") mergeSort();
        else if (type == "quick") quickSort();
      });

      document.getElementById("stopButton").addEventListener("click", () => {
        isStopped = true;
        isPaused = false;
        document.getElementById("pauseButton").innerHTML = "Pause";
        // if user presses stop button and random bars is not generated then generate rnadom bars.
        if (!isGenerated && !isSorted) generateRandomArray();
      });

      document.getElementById("pauseButton").addEventListener("click", () => {
        // if currently sorting is in progress then isStopped will be false.
        if (!isStopped) {
          // toggle button between pause and resume
          if (isPaused) {
            document.getElementById("pauseButton").innerHTML = "Pause";
            isPaused = false;
          } else {
            document.getElementById("pauseButton").innerHTML = "Resume";
            isPaused = true;
          }
        }
      });

      document.getElementById("clearButton").addEventListener("click", () => {
        // if currently sorting is in progress then isStopped will be false.
        if (isStopped) {
          // toggle button between pause and resume
          isSorted = false;
          isStopped = true;
          isPaused = false;
          n = 0;
          container.innerHTML = "";
        }
      });

      document.getElementById("inputButton").addEventListener("click", () => {
        // if currently sorting is in progress then isStopped will be false.
        if (isStopped) {
          // toggle button between pause and resume
          isGenerated = true;
          isSorted = false;
          isStopped = true;
          isPaused = false;
          n = barSlider.value;
          lineWidth = width / n - 1;
          container.innerHTML = "";
          var inputValue = inputElement.value.trim();
          inputElement.value = "";

          // Split the input value into an array of numbers
          var numbersArray = inputValue.split(" ");

          // Convert the array of strings to an array of numbers
          numbersArray = numbersArray.map(Number);

          n = numbersArray.length;

          lineWidth = width / n - 1;

          for (let i = 0; i < n; i++) {
            heights[i] = parseInt(numbersArray[i]);
            bars.push(document.createElement("div"));
            bars[i].style.width = `${lineWidth}px`;
            bars[i].style.height = `${heights[i]}px`;
            bars[i].style.transform = `translate(${i * lineWidth + i}px)`;
            bars[i].style.backgroundColor = "white";
            bars[i].className = "bar";
            container.appendChild(bars[i]);

            // if there are more numer of bars then it is not feasible to show bar values because they gets mixed up.
            if (n <= 60) {
              barValues.push(document.createElement("div"));
              barValues[i].innerHTML = heights[i];
              barValues[i].style.marginBottom = `${heights[i] + 5}px`;
              barValues[i].style.transform = `translate(${
                i * lineWidth + i
              }px)`;
              barValues[i].className = "barValue";
              container.appendChild(barValues[i]);
            }
          }
        }
      });
    </script>
  </body>
</html>
